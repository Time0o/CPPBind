# Type translator base class implementation. Each backend must provide a class
# deriving from 'TypeTranslator(...)' which implements a set of "rules"
# describing how to represent types in the target language as well as how to
# translate function parameters and return values etc.

import os
from abc import ABCMeta
from collections import deque
from functools import wraps
from pycppbind import Identifier as Id, Options
from util import is_iterable


class TypeTranslatorState:
    def __init__(self):
        self.impls = {}

_state = TypeTranslatorState()


# Type translation rule.
class Rule:
    def __init__(self,
                 type_matcher,
                 action,
                 action_before=None,
                 action_after=None):

        # Some lambda that returns true if passed a type that this rule should
        # match.
        self._type_matcher = type_matcher

        # Action to be performed on a match, each action returns a source code
        # snippet that is inserted into the code generated by CPPBind.
        self._action = action

        self._action_before = action_before
        self._action_after = action_after

    def matches(self, type_instance):
        return self._type_matcher(type_instance)

    def execute(self, *args, **kwargs):
        output = []

        output += self._execute(self._action_before, *args, **kwargs)
        output += self._execute(self._action, *args, **kwargs)
        output += self._execute(self._action_after, *args, **kwargs)

        return '\n'.join(output)

    @staticmethod
    def _execute(actions, *args, **kwargs):
        if actions is None:
            return []

        if not is_iterable(actions):
            actions = [actions]

        output = []
        for action in actions:
            out = action(*args, **kwargs)
            if out is not None:
                output.append(out)

        return output


# Type translation rule lookup structure. Maintains a list of all rules for a
# given backend and can be used to find the correct rule of a certain kind for
# a given type.
class RuleLookup:
    def __init__(self):
        self._lookup = {}

        # This should be set to 'custom' before a custom type translation rules
        # module is imported (see below). Custom type translation rules are
        # maintained separately and given priority over default ones.
        self.mode = 'default'

    def add_rule(self, type_matcher, action, **kwargs):
        rule = Rule(type_matcher=type_matcher,
                    action=action,
                    **kwargs)

        if action.__name__ not in self._lookup:
            self._lookup[action.__name__] = {
                'default': deque(),
                'custom': deque()
            }

        self._lookup[action.__name__][self.mode].append(rule)

    def find_rule(self, type_instance, action):
        if action.__name__ not in self._lookup:
            raise RuntimeError(f"no '{action.__name__}' rule")

        for mode in ['custom', 'default']:
            for rule in self._lookup[action.__name__][mode]:
                try:
                    if rule.matches(type_instance):
                        return rule
                except Exception as e:
                    raise RuntimeError(f"invalid '{action.__name__}' rule: {e}")

        raise RuntimeError(f"no '{action.__name__}' rule matches '{type_instance}'")


# Create a type translator base class where 'be' is be the name of the backend.
# For example, the C type translator should inherit from 'TypeTranslator('c')'.
def TypeTranslator(be):
    global _state

    if be in _state.impls:
        return _state.impls[be]

    # A bit of metaclass magic that automatically merges the default type
    # translator and the user provided one (if one exists). The latter must
    # always reside in a file named '{tt_dir}/{be}_type_translator.py' where
    # 'tt_dir' is specified via the
    # '--output-custom-type-translation-rules-directory' command line and 'be'
    # is the name of the backend. Both type translator implementations must
    # additionally inherit from the same 'TypeTranslator(...)' base class.
    class TypeTranslatorMeta(ABCMeta):
        def __init__(cls, name, bases, clsdict):
            super().__init__(name, bases, clsdict)

            mro = cls.mro()

            # This is automatically executed whenever a class deriving from
            # 'TypeTranslator(...)' is defined.
            if len(mro) == 3:
                TypeTranslatorMeta.add_custom_rules(cls, name)

        @staticmethod
        def add_custom_rules(cls, name):
            # Check whether custom rules module exists.
            custom_rules_dir = Options.output_custom_type_translation_rules_directory
            if not custom_rules_dir:
                return

            custom_rules_file = f"{(Id(name).format(case=Id.SNAKE_CASE))}.py"

            custom_rules_path = os.path.join(custom_rules_dir, custom_rules_file)

            if not os.path.exists(custom_rules_path):
                return

            cls._rule_lookup.mode = 'custom'

            # Import custom rule module.
            custom_rules_mod, _ = os.path.splitext(custom_rules_path)
            custom_rules_mod = custom_rules_mod.replace('/', '.')

            from importlib import import_module
            import_module(custom_rules_mod)

    class TypeTranslatorGeneric(metaclass=TypeTranslatorMeta):
        _rule_lookup = RuleLookup()

        # Rule decorator, basic usage is as follows:
        #
        # @rule(lambda t: t.is_fundamental()) # Match fundamental types.
        # def input(cls,
        #           t,     # Concrete type.
        #           args): # Additional rule kind specific arguments, e.g.
        #     #...         # function name or parameter name/offset for input rules.
        @classmethod
        def rule(cls, type_matcher, before=None, after=None):
            def rule_decorator(action):
                cls._rule_lookup.add_rule(type_matcher=type_matcher,
                                          action=action,
                                          action_before=before,
                                          action_after=after)

                @classmethod
                @wraps(action)
                def rule_wrapper(derived_cls, type_instance, args=None):
                    rule = cls._rule_lookup.find_rule(
                        type_instance=type_instance, action=action)

                    return rule.execute(derived_cls, type_instance, args)

                return rule_wrapper

            return rule_decorator

    _state.impls[be] = TypeTranslatorGeneric

    return TypeTranslatorGeneric
